\documentclass[a4paper,12pt]{article}

% --- PAQUETS ESSENTIELS ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel} % Typographie française
\usepackage{geometry}      % Marges
\geometry{hmargin=2.5cm,vmargin=2.5cm}
\usepackage{graphicx}      % Images
\usepackage{hyperref}      % Liens
\usepackage{float}         % Positionnement H
\usepackage{titlesec}      % Titres
\usepackage{xcolor}        % Couleurs

% --- CONFIGURATION DU CODE (SQL & PHP) ---
\usepackage{listings}

% Couleurs personnalisées
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Style global avec gestion des ACCENTS français
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    % C'est ici qu'on règle le problème des accents dans le code :
    literate={é}{{\'e}}1 {è}{{\`e}}1 {à}{{\`a}}1 {ç}{{\c{c}}}1 {œ}{{\oe}}1 {ù}{{\`u}}1 {É}{{\'E}}1 {È}{{\`E}}1 {À}{{\`A}}1 {Ç}{{\c{C}}}1 {Œ}{{\OE}}1 {Ê}{{\^E}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
}
\lstset{style=mystyle}

% --- INFOS DU DOCUMENT ---
\title{\textbf{Rapport de Projet SGBD : Gestion de Menus de Restaurants}}
\author{
    Abeille Thibault \\
    Bély Raphaël \\
    Guiot Numa \\
    Picarel Enzo
}
\date{\today}

\begin{document}

% Page de titre
\maketitle
\thispagestyle{empty}
\newpage

% Table des matières
\tableofcontents
\newpage

% ============================================================
% PARTIE 1 : MODÉLISATION DES DONNÉES
% ============================================================
\section{Modélisation des données}

\subsection{Description du contexte}

\subsubsection{Contexte}

Le but de ce projet est de concevoir une architecture de base de données solide et fonctionnelle, afin d’implémenter en PHP un site faisant le lien entre des restaurants souhaitant mettre leurs plats en ligne et les clients désireux de commander auprès d’eux. Concrètement, il s’agit d’une implémentation qui se rapproche d’un service de type UberEats ou Deliveroo. \\

Pour améliorer l’expérience de chaque utilisateur, qu’il soit client ou restaurateur, plusieurs fonctionnalités ont été mises en place : affichage de restaurants selon une catégorie ou une distance donnée, accès à une page de statistiques sur les plats et les clients, ou encore gestion des programmes de fidélité via un système de points. La publication et la commande de formules représentent également un volet central du projet. \\

Le site permet en plus d’informer les utilisateurs sur la composition nutritionnelle des produits, notamment leur teneur énergétique et en protéines. Enfin, les clients peuvent suivre l’avancement de leur commande à chaque étape, depuis la sélection des plats jusqu’à la réception, et consulter l’historique de leurs commandes passées.
 


\subsubsection{Règles de gestion}
Nous avons implémenté les règles de gestion suivantes pour garantir la cohérence des données :
\paragraph{Restaurants et Carte}
\begin{itemize}
    \item \textbf{RG01 :} Un restaurant est défini par un nom, une adresse et une position géographique (GPS).
    \item \textbf{RG02 :} Un restaurant peut appartenir à plusieurs catégories (ex: "Italien" et "Pizzeria"), mais une catégorie peut regrouper plusieurs restaurants.
    \item \textbf{RG03 :} Un item (plat, boisson) appartient à un seul restaurant.
    \item \textbf{RG04 :} Un item est classé dans une unique catégorie d'item (ex: "Entrée", "Plat", "Dessert").
    \item \textbf{RG05 :} La composition d'un item est détaillée par une liste d'ingrédients avec leur quantité (en grammes) pour permettre le calcul nutritionnel.
\end{itemize}

\paragraph{Clients et fidélité}
\begin{itemize}
    \item \textbf{RG06 :} Un client est identifié par une adresse email unique.
    \item \textbf{RG07 :} Via ses commandes, un client qui a un compte lié (au restaurant) cumule des points de fidélité indépendamment pour chaque restaurant 
    \item \textbf{RG08 :} Des remises (pourcentage ou item offert) sont débloquées lorsque le client atteint certains seuils de points définis par le restaurant.
    \item \textbf{RG09 :} Si le client à un compte lié au restaurant, il peut déposer un commentaire contenant une note, visible par les autres clients.
\end{itemize}

\paragraph{Commandes}
\begin{itemize}
    \item \textbf{RG10 :} Une commande est passée par un client auprès d'un unique restaurant (pas de commande multi-restaurants).
    \item \textbf{RG11 :} Un client ne peut avoir qu'une seule commande "en cours" (non achevée) par restaurant à un instant T.
    \item \textbf{RG12 :} Si un client ajoute un item alors qu'une commande est déjà ouverte pour ce restaurant, l'item est ajouté à la commande existante. Sinon, une nouvelle commande est créée.
    \item \textbf{RG13 :} Si un client ajoute un item déjà présent dans sa commande, la quantité de cet item est incrémentée (pas de doublon de ligne).
    \item \textbf{RG14 :} Le prix total d'une commande est calculé et mis à jour automatiquement (via Trigger) à chaque ajout, modification ou suppression d'item ou de formule.
    \item \textbf{RG15 :} La suppression d'une commande entraîne la suppression automatique de tout son contenu (items et formules) via la contrainte ON DELETE CASCADE.
\end{itemize}

\paragraph{Formules (ou Menu)}
\begin{itemize}
    \item \textbf{RG16 :} Une formule est définie par un prix fixe et une structure de catégories (ex: 1 Entrée + 1 Plat).
    \item \textbf{RG17 :} Une formule peut avoir des conditions de validité (jours de la semaine, horaires, midi/soir).
    \item \textbf{RG18 :} Lors de l'achat d'une formule, les items choisis par le client sont liés à une instance spécifique de cette formule dans la commande, afin de distinguer les items "au menu" des items "à la carte
\end{itemize}

\paragraph{Géolocalisation}
\begin{itemize}
    \item \textbf{RG19 :} La recherche par proximité affiche uniquement les restaurants situés dans un rayon défini (par défaut 2km) autour de la position de l'utilisateur.
    \item \textbf{RG20 :} La distance est calculée "à vol d'oiseau" sur la sphère terrestre (formule de géographie PostGIS).
\end{itemize}

\newpage


\subsection{Modèle Entité-Association (E-A)}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{schema_entite_association.jpg} 
    \caption{Diagramme Entité-Association de la base de données}
    \label{fig:mcd}
\end{figure}

\subsection{Opérations prévues et implémentées}
Nous avons identifié et implémenté les opérations suivantes, classées par domaine fonctionnel :

\begin{enumerate}
    \item \textbf{Consultation et Navigation :}
    \begin{itemize}
        \item \textbf{Liste des restaurants :} Affichage paginé des restaurants avec possibilité de filtrage dynamique par catégorie (Italien, Fast-Food, etc.) via des requêtes SQL paramétrées.
        \item \textbf{Consultation du menu :} Affichage hiérarchique des plats regroupés par catégorie (Entrées, Plats, Desserts).
        \item \textbf{Détail nutritionnel :} Consultation de la composition d'un plat. Une requête SQL avec jointures (\texttt{INNER JOIN}) permet de récupérer la liste des ingrédients et de calculer les valeurs nutritionnelles (Kcal, Protéines) pondérées pour 100g de produit fini.
    \end{itemize}

    \item \textbf{Mise à jour et Gestion du Panier (Transactionnel) :}
    \begin{itemize}
        \item \textbf{Ajout d'items simples :} Utilisation d'une procédure stockée PL/pgSQL (\texttt{ajouter\_au\_panier}) qui gère automatiquement la création de la commande si elle n'existe pas encore (mécanisme de "panier actif") ou la mise à jour de la quantité si l'item est déjà présent.
        \item \textbf{Tunnel de commande :} Pour les formules complexes, nous avons mis en place un processus étape par étape en PHP (via \texttt{\$\_SESSION}). L'enregistrement final utilise une transaction atomique pour insérer simultanément le choix de la formule et ses composants dans les tables \texttt{contenir\_formules} et \texttt{details\_commande\_formule}. Concrètement, le temps que l'opération ce termine, le résultat est stocké au fur et à mesure dans la mémoire vive du serveur. Il n'est stocké dans la base de donnée qu'à la fin, dans le but de ne pas polluer la base avec des données incomplète.
        \item \textbf{Annulation :} Possibilité d'annuler une commande en cours, déclenchant une suppression en cascade (\texttt{ON DELETE CASCADE}) de tous les items associés.
    \end{itemize}

    \item \textbf{Automatisation et Statistiques :}
    \begin{itemize}
        \item \textbf{Calcul automatique du prix :} Implémentation d'un \textbf{Trigger} qui se déclenche après chaque insertion, modification ou suppression dans le panier. Il recalcule instantanément le montant total de la commande en additionnant le prix des items à la carte et des formules.
        \item \textbf{Historique client :} Agrégation des données pour afficher l'historique des commandes passées avec leur état et leur contenu détaillé.
    \end{itemize}

    \item \textbf{Géolocalisation (PostGIS) :}
    \begin{itemize}
        \item \textbf{Recherche par proximité :} Utilisation de l'extension spatiale \textbf{PostGIS}. Nous utilisons les fonctions \texttt{ST\_MakePoint} pour créer des géométries à partir des coordonnées GPS et \texttt{ST\_DWithin} pour filtrer les restaurants dans un rayon précis (2km).
        \item \textbf{Calcul de distance :} Affichage de la distance réelle entre le client et le restaurant grâce à la fonction \texttt{ST\_Distance} projetée sur la sphère terrestre (\texttt{geography}).
    \end{itemize}
\end{enumerate}

\subsection{Évolution par rapport au premier modèle}

Lors de la phase de développement, nous avons identifié une limitation importante dans notre première ébauche concernant la gestion des formules (menus).

Comme le montre la Figure \ref{fig:mcd_v1}, notre modélisation initiale de l'entité \texttt{Formules} était incomplète. Elle était reliée au restaurant (\textit{offrir}) et à la commande (\textit{choisir}), mais elle manquait de définition structurelle.

\paragraph{Problème identifié :}
Il était impossible de définir de quoi était composée une formule type (par exemple : "Une Entrée au choix + Un Plat au choix"). Le système ne pouvait pas savoir quels types de plats le client devait choisir pour valider sa formule.

\paragraph{Correction apportée :}
Pour pallier ce manque, nous avons ajouté l'association \textbf{\texttt{composer\_formule}} (visible sur le schéma final) reliant l'entité \texttt{Formules} à l'entité \texttt{Categories\_items}.

Cette modification structurelle permet désormais de :
\begin{itemize}
    \item Définir la "recette" d'un menu (ex: 1 item de catégorie "Boisson" + 1 item de catégorie "Plat").
    \item Implémenter la logique du "Tunnel de commande" en guidant l'utilisateur étape par étape pour choisir les bons items dans les bonnes catégories.
\end{itemize}
\begin{figure}[h!]
    \centering
    % Assurez-vous que le fichier est bien dans votre dossier projet
    \includegraphics[width=0.9\textwidth]{diagramme_entité_association_v1.pdf}
    \caption{Première version du diagramme Entité-Association}
    \label{fig:mcd_v1}
\end{figure}

% ============================================================
% PARTIE 2 : SCHÉMA RELATIONNEL
% ============================================================
\section{Schéma Relationnel}

\subsection{Passage au relationnel}

\begin{figure}[H] % Le [H] force l'image à rester ICI (nécessite \usepackage{float})
    \centering
    \includegraphics[width=1.1\textwidth]{schéma_relationnel.jpg}
    
    \caption{Diagramme UML du schéma relationnel de la base de données}
    
    \label{fig:uml}
\end{figure}

\subsection{Contraintes et Dépendances}

L'intégrité et la cohérence de la base de données sont assurées par plusieurs mécanismes clés :

\begin{itemize}
    \item \textbf{Clés et Unicité :} L'utilisation de clés primaires artificielles (\texttt{SERIAL}) et de contraintes \texttt{UNIQUE} (sur les emails clients et restaurants) garantit l'identification unique de chaque entité.
    
    \item \textbf{Intégrité Référentielle :} Un réseau strict de clés étrangères relie les tables, empêchant, par exemple, la création d'un plat sans restaurant associé.
    
    \item \textbf{Suppression en Cascade (\texttt{ON DELETE CASCADE}) :} Cette clause est systématisée pour automatiser le nettoyage. La suppression d'un restaurant entraîne instantanément celle de ses cartes, horaires et commandes, évitant les données orphelines.
    
    \item \textbf{Validité des Données :} Des contraintes de domaine comme \texttt{CHECK} (ex : note comprise entre 1 et 5) et l'usage de types \texttt{ENUM} (ex : état d'une commande) verrouillent les formats de saisie.
    
    \item \textbf{Triggers Métier :} La cohérence dynamique est déléguée à des triggers PL/pgSQL. Ils recalculent automatiquement les prix totaux lors des modifications de panier (\texttt{trg\_update\_prix\_items}) et mettent à jour les notes moyennes des restaurants (\texttt{trg\_calcul\_note}) en temps réel.
\end{itemize}

\subsection{Normalisation (3NF)}

Le schéma respecte la Troisième Forme Normale (3NF) pour garantir l'absence de redondance :

\begin{itemize}
    \item \textbf{1NF (Atomicité) :} Chaque attribut contient une valeur unique. La composition des plats n'est pas une liste, mais est gérée via la table d'association \texttt{composer}.
    \item \textbf{2NF (Dépendance totale) :} Tout attribut non-clé dépend de la clé primaire entière. Dans \texttt{contenir\_items}, la \texttt{quantite} dépend bien du couple \texttt{(commande\_id, item\_id)}.
    \item \textbf{3NF (Dépendance directe) :} Aucun attribut non-clé ne dépend d'un autre attribut non-clé. Par exemple, l'adresse d'un client dépend uniquement de son \texttt{client\_id}.
\end{itemize}

\textit{Note :} Bien que le champ \texttt{prix\_total\_remise} dans la table \texttt{commandes} soit une donnée calculable (dérivée), nous avons choisi de le stocker pour des raisons de performance. La cohérence avec la 3NF est maintenue artificiellement grâce à l'utilisation stricte de triggers qui garantissent que ce champ reflète toujours exactement la somme des items.

% ============================================================
% PARTIE 3 : IMPLANTATION (PostgreSQL)
% ============================================================
\section{Implantation}

\subsection{Création de la base de données}
SGBD utilisé : \textbf{PostgreSQL} avec extension \textbf{PostGIS}.



\subsection{Architecture Logicielle : Le choix du modèle MVC}

Pour l'implémentation de l'interface utilisateur, nous avons opté pour l'architecture Modèle-Vue-Contrôleur (MVC). Ce motif de conception nous a permis de structurer notre application PHP native en séparant clairement les responsabilités, ce qui est crucial pour un projet mêlant des règles de gestion complexes (SQL/PLpgSQL) et une interface web interactive. \\

Concrètement, l'application s'articule autour de trois composants distincts : 
\begin{itemize} 
    \item \textbf{Le Modèle (M) :} Il représente la couche d'accès aux données. Dans notre projet, les classes situées dans le dossier \texttt{models/} (ex: \texttt{Restaurant.php}, \texttt{Commandes.php}) encapsulent toute la logique SQL. Elles sont les seules autorisées à communiquer avec la base PostgreSQL via l'objet PDO. C'est ici que sont appelées nos procédures stockées complexes (comme \texttt{ajouter\_au\_panier}) et nos requêtes PostGIS, garantissant que le code SQL est centralisé et non dispersé dans les pages HTML. 
    
    \item \textbf{La Vue (V) :} Située dans le dossier \texttt{views/}, elle gère exclusivement la présentation. Elle reçoit les données brutes fournies par le contrôleur (sous forme de tableaux PHP) et les transforme en code HTML intelligible pour l'utilisateur (cartes de restaurants, tableaux de menus, formulaires). Elle ne contient aucune logique métier ni requête SQL, ce qui facilite la maintenance du design et l'intégration du CSS. 
    
    \item \textbf{Le Contrôleur (C) :} C'est le chef d'orchestre de l'application (nos fichiers à la racine \texttt{src/}, comme \texttt{index.php} ou \texttt{commande.php}). Il intercepte les requêtes HTTP de l'utilisateur (GET/POST), vérifie les permissions (gestion de session, authentification), sollicite le Modèle pour récupérer ou modifier les données, puis sélectionne la Vue appropriée pour afficher le résultat. \\
\end{itemize} 

\textbf{Justification et Avantages :} Le choix de MVC offre plusieurs avantages majeurs pour ce projet : 
\begin{enumerate} 
    \item \textbf{Séparation des préoccupations :} En isolant la logique métier de l'interface graphique, nous respectons le principe de responsabilité unique. Cela permet de modifier la structure de la base de données (ex: optimisation d'une requête SQL) sans impacter le code de l'interface utilisateur. 
    
    \item \textbf{Sécurité et Robustesse :} Le contrôleur agit comme un filtre de sécurité qui valide les entrées utilisateur (comme les coordonnées GPS ou les ID de commande) avant qu'elles n'atteignent la couche de données, réduisant les risques d'injections ou d'erreurs logiques. 
    
    \item \textbf{Travail collaboratif :} Cette structure a facilité le développement en équipe, permettant de travailler parallèlement sur le "Backend" (création des triggers et modèles PHP) et le "Frontend" (design des vues et expérience utilisateur) sans conflits de code majeurs.      
\end{enumerate}

\subsection{Implémentation des opérations}

Nous avons choisi de déporter une grande partie de la logique métier directement dans la base de données via des procédures stockées PL/pgSQL. Cela garantit la rapidité d'exécution et l'intégrité des données.

\subsubsection{Gestion transactionnelle du panier}

L'ajout d'une formule au panier est une opération complexe qui nécessite plusieurs étapes : vérifier si une commande existe (ou la créer), ajouter la formule, puis lier chaque item choisi (entrée, plat, dessert) à cette formule spécifique.

Pour réaliser cela en une seule transaction atomique, nous avons créé la fonction \texttt{ajouter\_formule\_complete}. Elle utilise la fonction \texttt{unnest} pour transformer un tableau d'identifiants PHP en lignes SQL insérables.

\begin{lstlisting}[language=SQL, caption=Fonction d'ajout de formule avec gestion des tableaux]
CREATE OR REPLACE FUNCTION ajouter_formule_complete(
    p_client_id INT,
    p_restaurant_id INT,
    p_formule_id INT,
    p_items_ids INT[] -- Tableau des IDs des items choisis
) RETURNS BOOLEAN AS $$
DECLARE
    v_commande_id INT;
    v_contenir_formule_id INT;
BEGIN
    -- 1. Récupération ou création intelligente de la commande
    v_commande_id := obtenir_ou_creer_commande(p_client_id, p_restaurant_id);

    -- 2. Ajout de la formule
    INSERT INTO contenir_formules (commande_id, formule_id)
    VALUES (v_commande_id, p_formule_id)
    RETURNING id INTO v_contenir_formule_id; 

    -- 3. Insertion en masse des items liés via unnest()
    INSERT INTO details_commande_formule (contenir_formule_id, item_id)
    SELECT v_contenir_formule_id, unnest(p_items_ids);

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}

\subsubsection{Automatisation du calcul du prix (Triggers)}

Afin d'éviter les incohérences de montants, le prix total de la commande n'est jamais calculé côté PHP. Un \textbf{Trigger} se déclenche automatiquement après chaque ajout, modification ou suppression dans le panier (que ce soit un item seul ou une formule).

Ce mécanisme recalcule la somme de tous les éléments et met à jour le champ \texttt{prix\_total\_remise} de la commande en temps réel.

\begin{lstlisting}[language=SQL, caption=Trigger de mise à jour automatique du prix]
-- Trigger déclenché à chaque modification du contenu du panier
CREATE TRIGGER trg_update_prix_items
AFTER INSERT OR UPDATE OR DELETE ON contenir_items
FOR EACH ROW
EXECUTE FUNCTION update_prix_commande_func();
\end{lstlisting}

% ============================================================
% PARTIE 4 : UTILISATION ET INTERFACE
% ============================================================
\section{Utilisation}

\subsection{Environnement d'exécution}
\begin{itemize}
    \item \textbf{Serveur :} Apache (Linux/Ubuntu)
    \item \textbf{Base de données :} PostgreSQL 13+
    \item \textbf{Langage :} PHP 7.4+ (sans framework lourd type Symfony)
    \item \textbf{Extensions :} \texttt{php-pgsql} pour la connexion BDD.
\end{itemize}

\subsection{Notice d'utilisation pendant le développement}
\begin{enumerate}
    \item Importer la structure via \texttt{create.sql} sur sa base de données (nous avons utilisé les bases personnelles de l'ENSEIRB).
    \item Peupler la base via \texttt{insert.sql}.
    \item Accéder au site via l'url suivant https://zzz.tabeille001.bordeaux-inp.fr/src/index.php en s'assurant d'être connecté sur le réseaux de Bordeaux INP
    \item Enfin, se connecter/créer un compte en utilisant un email ou utiliser le mode invité.
\end{enumerate}

\section{Description des Interfaces et Fonctionnalités Implémentées}

L'application est divisée en trois interfaces distinctes, accessibles selon le rôle de l'utilisateur (Client, Invité, Restaurateur). 

\subsection{Interface Client (Utilisateur Connecté)}
L'interface client offre l'expérience la plus complète. Après authentification, l'utilisateur a accès à un tableau de bord personnalisé.

\subsubsection{Recherche et Sélection de Restaurant}
La page d'accueil présente la liste des restaurants partenaires. Plusieurs fonctionnalités de recherche avancée ont été implémentées :
\begin{itemize}
    \item \textbf{Géolocalisation (PostGIS) :} Un bouton permet de trier les restaurants par proximité. L'application récupère la position GPS du navigateur, envoie les coordonnées au serveur, et une requête spatiale (\texttt{ST\_Distance}) calcule la distance exacte en kilomètres, affichée dynamiquement sur chaque carte.
    \item \textbf{Filtres par catégorie :} Possibilité de filtrer par type de cuisine (Italien, Fast-Food, Gastronomique, etc.).
    \item \textbf{État d'ouverture :} Grâce à une jointure complexe avec la table \texttt{horaires\_ouverture}, l'interface indique visuellement si un restaurant est actuellement \textbf{ouvert} ou \textbf{fermé}.
\end{itemize}

\subsubsection{Système d'Avis et Notation}
Afin de guider les utilisateurs, un système de notation communautaire a été développé :
\begin{itemize}
    \item \textbf{Dépôt d'avis certifiés :} Seuls les clients ayant déjà effectué une commande dans un restaurant (vérification d'antériorité via la table \texttt{fidelite}) ont le droit de laisser une note (1 à 5 étoiles) et un commentaire.
    \item \textbf{Visibilité publique :} Les notes et les commentaires sont publics et visibles par tous les utilisateurs (y compris les invités).
    \item \textbf{Calcul automatique :} La note moyenne affichée sur la carte du restaurant est recalculée instantanément à chaque nouvel avis grâce à un Trigger SQL, garantissant une information toujours à jour sans alourdir les requêtes de lecture.
\end{itemize}

\subsubsection{Prise de Commande par Plats et par Formules}
La navigation dans le menu d'un restaurant propose deux modes de commande :
\begin{enumerate}
    \item \textbf{À la carte :} Ajout direct d'items au panier. Si l'item possède des variantes (sauces, accompagnements), un système de liste déroulante dynamique permet d'ajouter ces compléments.
    \item \textbf{Par Formule :} Pour les menus complexes (ex: Entrée + Plat + Dessert), nous avons développé un \textit{configurateur étape par étape}. L'utilisateur ne voit que les plats éligibles pour l'étape en cours. La validation finale déclenche une transaction SQL atomique qui lie tous les items choisis à une instance unique de formule.
\end{enumerate}
Au fur et à mesure que la commande est créer, un petit aperçu de celle-ci est visible sur la droite de l'écran. Cela permet à l'utilisateur de savoir ce qu'il a commandé.

\subsubsection{Fidélité et Récompenses}
Un système de gamification récompense les clients réguliers :
\begin{itemize}
    \item Chaque commande rapporte des points de fidélité spécifiques au restaurant.
    \item \textbf{Déblocage de récompenses :} Le système vérifie automatiquement le solde de points. Si les seuils sont atteints, le client peut bénéficier d'items offerts ou de remises en pourcentage sur sa prochaine commande.
\end{itemize}

\subsubsection{Suivi et Historique}
Les commandes sont validés (On imagine qu'un paiement peut être mis en place à ce moment là) dans la section \textbf{panier}.
Puis, le client peut valider la réception dans la section \textbf{suivie}, il atteste avoir bien reçu la commande.
Enfin, les information des la commandes sont passé dans un \textbf{historique} que le client peut consulter à tout moment.

\subsection{Interface Invité (Guest)}
Afin de réduire la friction à l'entrée, un mode "Invité" a été développé.
\begin{itemize}
    \item \textbf{Compte temporaire :} Un compte client est créé à la volée avec une durée de vie limitée. Il n'a donc pas accès à un historique, mais il peut quand même valider sa commande et confirmer sa réception.
    \item \textbf{Limitations :} L'invité a accès à toutes les fonctions de commande et peut consulter les avis laissés par les autres, mais il ne peut pas poster de commentaire ni cumuler de points de fidélité.
    \item \textbf{Nettoyage :} Une logique métier détecte la fin du cycle de commande et supprime automatiquement les données du compte invité.
\end{itemize}

\subsection{Interface Restaurateur (Back-Office)}
Cette interface sécurisée est dédiée aux professionnels pour la gestion de leur établissement.

\subsubsection{Gestion du Menu}
Le restaurateur dispose d'outils lui permettant la création/insertion ainsi que certaines modification et suppression  :
\begin{itemize}
    \item \textbf{Création de Plats :} Ajout de nouveaux items avec définition du prix, de la catégorie et association possible avec des compléments existants.
    \item \textbf{Création de Formules :} Interface permettant de définir un prix global, de composer la structure du menu (ex: choisir les catégories "Entrée" et "Plat") et de définir des conditions de validité (jours, horaires).
    \item \textbf{Gestion des Horaires :} Ajout et suppression de créneaux horaires d'ouverture.
\end{itemize}

\subsubsection{Tableau de Bord Statistique}
Une page de statistiques exploitant des requêtes d'agrégation complexes permet au restaurateur de visualiser son chiffre d'affaires mensuel et la répartition des ventes (carte vs formules).


\end{document}